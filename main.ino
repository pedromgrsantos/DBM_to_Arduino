/* Net TP2_2022_IOPT_TOOLS - IOPT */
/* Automatic code generated by IOPT2C XSLT transformation. */
#include "math.h"
#include <SoftwareSerial.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <stdlib.h>
#include "net_types.h"
LiquidCrystal_I2C lcd(0x27, 16, 4);

int trace_control = TRACE_CONT_RUN;

//extern void httpServer_init();
//extern void httpServer_getRequest();
//extern void httpServer_sendResponse();
//extern void httpServer_disconnectClient();
//extern void httpServer_checkBreakPoints();
//extern void httpServer_finish();

static TP2_2022_IOPT_TOOLS_NetMarking marking;
static TP2_2022_IOPT_TOOLS_InputSignals inputs, prev_inputs;
static TP2_2022_IOPT_TOOLS_PlaceOutputSignals place_out;
static TP2_2022_IOPT_TOOLS_EventOutputSignals ev_out;

void setup()
{
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("PROJETO PEDRO SANTOS");
  lcd.setCursor(4, 2);
  lcd.print("MESTRADO IOT");
  delay(5000);
  lcd.clear();
  pinMode(GREEN_LED, OUTPUT); // Led for Sensor ativation
  pinMode(RED_LED, OUTPUT);   // Led for stand-by mode
  pinMode(BLUE_LED, OUTPUT);  // Led for Override Mode
  pinMode(OVERRIDE, INPUT);   // Jumper to simulate Override
  pinMode(METEORAIN, INPUT);   // Jumper to simulate Override
  createInitial_TP2_2022_IOPT_TOOLS_NetMarking( &marking );
  init_TP2_2022_IOPT_TOOLS_OutputSignals( &place_out, &ev_out );
  TP2_2022_IOPT_TOOLS_InitializeIO();
  TP2_2022_IOPT_TOOLS_GetInputSignals( &prev_inputs, NULL );
}

void loop() {
int y = analogRead(METEORAIN);
rainMap = map(y, 0, 900, 100, 0);
Serial.print("Valor do pino A0: ");
Serial.println(y);
Serial.print("Valor após conversão 0-100%: ");
Serial.println(rainMap);

  //Override Mode
  if (inputOverride == 1) {
    Serial.println("**********************");
    Serial.print("Override ON :");
    Serial.println(inputOverride);
    Serial.print(analogRead(OVERRIDE));
    Serial.println("A regar por açao manual...");
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(RED_LED, LOW);
    digitalWrite(BLUE_LED, HIGH);
    lcd.clear();
    lcd.setCursor(4, 0);
    lcd.print("Modo Manual");
    lcd.setCursor(0, 1);
    lcd.print("Contador: ");
    lcd.print(outputIrrigationDurationValue);

    // Sensor Mode
  } else if (outputIrrigationValue == 1 && inputOverride == 0 && outputSensorCheck == 1) {
    Serial.println("**********************");
    //Serial.print("Override OFF Value: ");
   //Serial.println(inputOverride);
    Serial.println("Override OFF");
    Serial.println("A regar por sensores... ");
    Serial.println(outputSensorCheck);
    //Serial.print("Valor Irrigacao: ");
    //Serial.println(outputIrrigationValue);
    //Serial.print("Override: ");
    //Serial.println(inputOverride);
    digitalWrite(RED_LED, LOW);
    digitalWrite(BLUE_LED, LOW);
    digitalWrite(GREEN_LED, HIGH);
    
    lcd.clear();
    lcd.setCursor(1, 0);
    lcd.print("Ativado por Sensor");
    lcd.setCursor(4, 1);
    lcd.print("Contador: ");
    lcd.print(outputIrrigationDurationValue);
    lcd.setCursor(3, 2);
    lcd.print("Pro. Chuva ");
    lcd.print(rainMap);
    lcd.print("%");
    lcd.setCursor(0, 3);
    lcd.print("H-Solo: ");
    lcd.print(inputSoilHumiValue);
    lcd.setCursor(12, 3);
    lcd.print("H-Ar: ");
    lcd.print(inputAirHumiValue);

    
    if (outputIrrigationDurationValue == 5) {
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("A verificar Sensores");
      delay(2000);
      lcd.clear();
    }



    // Stand-by Mode
  } else if (outputIrrigationValue == 0 && inputOverride == 0) {
    Serial.println("**********************");
    Serial.println("Override OFF");
    //    Serial.println(inputOverride);
    Serial.println("Stand-by Mode");
    Serial.println("Rega OFF");
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(BLUE_LED, LOW);
    digitalWrite(RED_LED, HIGH);
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("REGA DESATIVADA");
    lcd.setCursor(0, 2);
    lcd.print("MODO STAND-BY");
    

  }


  if ( trace_control != TRACE_PAUSE )
    TP2_2022_IOPT_TOOLS_ExecutionStep( &marking, &inputs, &prev_inputs, &place_out, &ev_out );
  else TP2_2022_IOPT_TOOLS_GetInputSignals( &inputs, NULL );
  if ( trace_control > TRACE_PAUSE ) --trace_control;

  TP2_2022_IOPT_TOOLS_LoopDelay();
}



#ifndef ARDUINO
int main()
{
  setup();

  do loop();
  while ( TP2_2022_IOPT_TOOLS_FinishExecution( &marking ) == 0 );


  return 0;
}
#endif


TP2_2022_IOPT_TOOLS_NetMarking* get_TP2_2022_IOPT_TOOLS_NetMarking()
{
  return &marking;
}

TP2_2022_IOPT_TOOLS_InputSignals* get_TP2_2022_IOPT_TOOLS_InputSignals()
{
  return &inputs;
}

TP2_2022_IOPT_TOOLS_PlaceOutputSignals* get_TP2_2022_IOPT_TOOLS_PlaceOutputSignals()
{
  return &place_out;
}

TP2_2022_IOPT_TOOLS_EventOutputSignals* get_TP2_2022_IOPT_TOOLS_EventOutputSignals()
{
  return &ev_out;
}
